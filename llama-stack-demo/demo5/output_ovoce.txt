Using Llama Stack version 0.2.22
Vector store name: vec_7cef4383
Vector store ID: vs_1364b1c1-43b6-46f8-8a44-91fa8f8b61fd
Using model granite-embedding-125m
File path: 05_05_variance.md
File create response: File(id='file-a3646e699cce4fca9d81337f013ac151', bytes=18439, created_at=1758745429, expires_at=1790281429, filename='05_05_variance.md', object='file', purpose='assistants')
File ingest response: VectorStoreFile(id='file-a3646e699cce4fca9d81337f013ac151', attributes={}, chunking_strategy=ChunkingStrategyVectorStoreChunkingStrategyAuto(type='auto'), created_at=1758745429, object='vector_store.file', status='completed', usage_bytes=0, vector_store_id='vs_1364b1c1-43b6-46f8-8a44-91fa8f8b61fd', last_error=None)
ID: resp-d0f3e76d-1e79-499a-ba71-4ddef85dedb0
Status: completed
Model: openai/gpt-4-turbo
Created at: 1758745437
Output items: 2

--- Output Item 1 ---
Output type: file_search_call
  Tool Call ID: call_CEgssrYfjL0klzlXkzcYewfI
  Tool Status: completed
  Queries: Class Ovoce
  Results: [OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=2.3834228307004546, text='osud bylo vše v&nbsp;naprostém pořádku. Ovšem zamysleme se nyní nad tím, co se stane ve chvíli, kdy metodě `smichej` předáme košík, do kterého je možné ukládat pouze hrušky (a to díky kovarianci, na které Java staví, můžeme)? Zde ono pověstné míchání hrušek s&nbsp;jablky nebude možné, ovšem důležité je, že překladač provádějící statickou typovou kontrolu *tento problém neodhalí*, zdrojový kód přeloží a nechá nás (nebo zákazníka) ho spustit:\n\n```java\nclass Ovoce {\n}\n\nclass Hruska extends Ovoce {\n    public String toString() {\n        return "Hruska";\n    }\n}\n\nclass Jablko extends Ovoce {\n    public String toString() {\n        return "Jablko";\n    }\n}\n\npublic class Variance2 {\n    public static void smichej(Ovoce[] kosik) {\n        kosik[0] = new Hruska();\n        kosik[1] = new Jablko();\n    }\n\n    public static void main(String[] args) {\n        Ovoce[] kosik = new Hruska[2];\n        smichej(kosik);\n\n        for (Ovoce ovoce:kosik) {\n            System.out.println(ovoce);\n        }\n    }\n}\n```\n\nChyba, která je v&nbsp;tomto zdánlivě triviálním příkladu skryta, je ve skutečnosti odhalena až za běhu programu, tedy v&nbsp;_runtime_ (což popravdě od statického typového systému většinou neočekáváme):\n\n```\nException in thread "main" java.lang.ArrayStoreException: Jablko\n        at Variance2.smichej(Variance2.java:19)\n        at Variance2.main(Variance2.java:24)\n\n```\n\nPoznámka: bez čtení navazujících kapitole se v&nbsp;rámci cvičení pokuste zamyslet nad tím, jak (a zda vůbec) je možné tento problém nějak uspokojivě vyřešit nebo zda se jedná o nepřekonatelnou vlastnost světa typových systémů.\n\n\n\n### Od Javy k&nbsp;Pythonu\n\nPodívejme se nyní na podobný příklad, ovšem tentokrát naprogramovaný nikoli v&nbsp;Javě, ale v&nbsp;Pythonu, samozřejmě s&nbsp;využitím typových anotací. Opět je vytvořena hierarchie tříd (a tedy i typů) nazvaných `Ovoce`, `Hruska` a `Jablko`. Demonstrační příklad dále obsahuje funkci pojmenovanou `smichej`, která do košíku s&nbsp;ovocem přidá jednu hrušku a jedno jablko. Samotný košík je přitom představován typem `List[Ovoce]` a celý příklad je tedy bez problémů spustitelný a i nástroj _Mypy_ v&nbsp;něm nenalezne žádný problém:\n\n@ mypy/variance-1.py\n\nVýsledek testu nástrojem Mypy, zda je zdrojový kód typově korektní:\n\n```\nmypy variance-1.py\n\n\nSuccess: no issues found in 1 source file\n```\n\n\n\n#### Modifikace typu &bdquo;košíku&ldquo;\n\nV&nbsp;dalším kroku předchozí demonstrační příklad nepatrně pozměníme. Košík (původně prázdný) již nebude typu `List[Ovoce'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=2.3758280136212195, text='adech (subtyping je sice odlišný od hierarchie tříd, pro jednoduchost ovšem nyní budeme na chvíli tyto rozdíly ignorovat).\n\n\n\n#### Hierarchie tříd `Ovoce`, `Hruska` a `Jablko`\n\nV&nbsp;prvním příkladu naprogramovaném v&nbsp;Javě je použita snadno pochopitelná hierarchie tříd `Ovoce`, `Hruska` a `Jablko` (takže se vracíme k&nbsp;našemu příkladu s&nbsp;ovocem). Ve statické metodě `smichej` v&nbsp;košíku mícháme hrušky s&nbsp;jablky (sic!). Ovšem této metodě předáváme košík představovaný polem hodnot typu `Ovoce`, takže vše bude v&nbsp;pořádku &ndash; jak v&nbsp;čase překladu (_compile time_), tak i v&nbsp;čase běhu (_runtime_):\n\n```java\nclass Ovoce {\n}\n\nclass Hruska extends Ovoce {\n    public String toString() {\n        return "Hruska";\n    }\n}\n\nclass Jablko extends Ovoce {\n    public String toString() {\n        return "Jablko";\n    }\n}\n\npublic class Variance1 {\n    public static void smichej(Ovoce[] kosik) {\n        kosik[0] = new Hruska();\n        kosik[1] = new Jablko();\n    }\n\n    public static void main(String[] args) {\n        Ovoce[] kosik = new Ovoce[2];\n        smichej(kosik);\n\n        for (Ovoce ovoce:kosik) {\n            System.out.println(ovoce);\n        }\n    }\n}\n```\n\n\n\n#### Problémový rys kovariance\n\nAž doposud bylo vše v&nbsp;naprostém pořádku. Ovšem zamysleme se nyní nad tím, co se stane ve chvíli, kdy metodě `smichej` předáme košík, do kterého je možné ukládat pouze hrušky (a to díky kovarianci, na které Java staví, můžeme)? Zde ono pověstné míchání hrušek s&nbsp;jablky nebude možné, ovšem důležité je, že překladač provádějící statickou typovou kontrolu *tento problém neodhalí*, zdrojový kód přeloží a nechá nás (nebo zákazníka) ho spustit:\n\n```java\nclass Ovoce {\n}\n\nclass Hruska extends Ovoce {\n    public String toString() {\n        return "Hruska";\n    }\n}\n\nclass Jablko extends Ovoce {\n    public String toString() {\n        return "Jablko";\n    }\n}\n\npublic class Variance2 {\n    public static void smichej(Ovoce[] kosik) {\n        kosik[0] = new Hruska();\n        kosik[1] = new Jablko();\n    }\n\n    public static void main(String[] args) {\n        Ovoce[] kosik = new Hruska[2];\n        smichej(kosik);\n\n        for (Ovoce ovoce:kosik) {\n            System.out.println(ovoce);\n        }\n    }\n}\n```\n\nChyba, která je v&nbsp;tomto zdánlivě triviálním příkladu skryta, je ve skutečnosti odhalena až za běhu programu, tedy v&nbsp;_runtime_ (což popravdě od statického typového systému většinou neočekáváme):\n\n```\nException in thread "main" java.lang.ArrayStoreException: Jablko\n        at Variance'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=2.0095457283748885, text=' mohou nastat čtyři varianty uplatněné na typy &bdquo;seznam ovoce&ldquo; a &bdquo;seznam hrušek&ldquo; (popř.&nbsp;si namísto &bdquo;seznam&ldquo; můžete doplnit &bdquo;pole&ldquo; nebo libovolnou jinou datovou kolekci, například množinu nebo i zásobník či frontu):\n\n1. _Covariance_: v&nbsp;tomto případě je `List[Hruška]` podtypem typu `List[Ovoce]` což v&nbsp;praxi znamená, že libovolná funkce akceptující argument typu `List[Ovoce]` bude akceptovat i argument typu `List[Hruška]`.\n\n1. _Contravariance_: v&nbsp;takto koncipovaném typovém systému bude `List[Ovoce]` podtypem typu `List[Hruška]` (což je jen zdánlivě nelogické), což znamená, že libovolná funkce akceptující argument `List[Hruška]` bude akceptovat i argument typu `List[Ovoce]`.\n\n1. _Invariance_: datový typ `List[Ovoce]` nemá z&nbsp;hlediska datového systému žádný vztah k `List[Hruška]` a při volání funkcí je tedy nelze zaměňovat. Tato varianta je sice typově bezpečná, ale může být v&nbsp;praxi poměrně rigidní.\n\n1. _Bivariance_: datový typ `List[Hruška]` je v&nbsp;tomto případě podtypem typu `List[Ovoce]` a současně `List[Ovoce]` je podtypem typu `List[Hruška]`. Tyto typy jsou tedy při volání zaměnitelné, což ovšem může být důsledky v&nbsp;době běhu programu (_runtime_).\n\n\n\n### Mají všechny typy variancí praktický význam?\n\nNa první pohled se to může možná zdát dosti podivné, ale všechny typy variance zmíněné v&nbsp;předchozím textu mají svůj význam a hlavně i praktické použití, i když se mohou zdát na první pohled &bdquo;nelogické&ldquo;. Ostatně některé příklady si ukážeme v&nbsp;navazujících podkapitolách. Situace je zajímavá zejména u funkcí, resp.&nbsp;u jejich parametrů a návratové hodnoty, protože právě zde se uplatňuje zdánlivě nelogická _kontravariance_ i když by se mohlo zdát, že jedinou ve všech oblastech &bdquo;správnou&ldquo; variancí je _kovariance_.\n\n\n\n### Malá odbočka: variance v&nbsp;klasickém objektově orientovaném jazyce\n\nS&nbsp;variancemi (přesněji řečeno těmi alespoň na první pohled &bdquo;logickými&ldquo;) se setkáme v&nbsp;klasických programovacích jazycích založených na myšlence objektově orientovaného programování. Příkladem může být C# či Java (v&nbsp;některých případech i TypeScript, který však umožňuje varianci změnit klíčovými slovy `in` a `out`). Programovací jazyk Java, na rozdíl od programovacího jazyka Go (který není čistě OOP jazykem), při volání funkcí a metod používají _kovarianci_, což ovšem může vést k&nbsp;běhovým (_runtime_) chybám. To si ostatně můžeme ukázat na velmi jednoduchých příkl'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.9171586057224455, text='2.smichej(Variance2.java:19)\n        at Variance2.main(Variance2.java:24)\n\n```\n\nPoznámka: bez čtení navazujících kapitole se v&nbsp;rámci cvičení pokuste zamyslet nad tím, jak (a zda vůbec) je možné tento problém nějak uspokojivě vyřešit nebo zda se jedná o nepřekonatelnou vlastnost světa typových systémů.\n\n\n\n### Od Javy k&nbsp;Pythonu\n\nPodívejme se nyní na podobný příklad, ovšem tentokrát naprogramovaný nikoli v&nbsp;Javě, ale v&nbsp;Pythonu, samozřejmě s&nbsp;využitím typových anotací. Opět je vytvořena hierarchie tříd (a tedy i typů) nazvaných `Ovoce`, `Hruska` a `Jablko`. Demonstrační příklad dále obsahuje funkci pojmenovanou `smichej`, která do košíku s&nbsp;ovocem přidá jednu hrušku a jedno jablko. Samotný košík je přitom představován typem `List[Ovoce]` a celý příklad je tedy bez problémů spustitelný a i nástroj _Mypy_ v&nbsp;něm nenalezne žádný problém:\n\n@ mypy/variance-1.py\n\nVýsledek testu nástrojem Mypy, zda je zdrojový kód typově korektní:\n\n```\nmypy variance-1.py\n\n\nSuccess: no issues found in 1 source file\n```\n\n\n\n#### Modifikace typu &bdquo;košíku&ldquo;\n\nV&nbsp;dalším kroku předchozí demonstrační příklad nepatrně pozměníme. Košík (původně prázdný) již nebude typu `List[Ovoce]` ale typu `List[Hruska]`, přičemž ve funkci `smichej` opět mícháme jablka s&nbsp;hruškami, ovšem nyní je přidáváme do seznamu, který akceptuje pouze hrušky. Jedná se tedy o obdobu druhého příkladu naprogramovaného v&nbsp;Javě, nyní ovšem zapsaného v&nbsp;jazyku s&nbsp;odlišným typovým systémem:\n\n@ mypy/variance-2.py\n\nTentokrát ovšem nástroj Mypy ve zdrojovém kódu nalezne chyby a dokonce navrhuje způsob jejich opravy. Tuto opravu ale, alespoň prozatím, nemůžeme použít:\n\n```\nmypy --strict variance-2.py \n\nvariance-2.py:31: error: Argument 1 to "smichej" has incompatible type "List[Hruska]"; expected "List[Ovoce]"  [arg-type]\nvariance-2.py:31: note: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance\nvariance-2.py:31: note: Consider using "Sequence" instead, which is covariant\nFound 1 error in 1 file (checked 1 source file)\n```\n\nNástroj Mypy (a především typový systém Pythonu) se tedy v&nbsp;tomto ohledu dosti podstatným způsobem odlišuje od typového systému Javy! Navíc nám tyto změny (resp.&nbsp;vylepšení) typového systému umožňují statickou typovou kontrolu, což v&nbsp;Javě nebylo plně možné.\n\n\n\n#### Úprava příkladu: tisk obsahu košíku s&nbsp;ovocem\n\nV&nbsp;navazujícím kroku demonstrační příklad z&nbsp;předchozího odstav'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.9133411430677658, text='## Variance\n\nV&nbsp;průběhu vývoje programovacích jazyků postupně vzniklo i poměrně velké množství typových systémů, přičemž mezi jednotlivými typovými systémy může být obrovské množství rozdílů, které určují jak jejich sílu, tak i snadnost použití. Velmi zajímavou (a možná poněkud méně známou) vlastností typových systémů je takzvaná _type variance_. Tento termín můžeme do češtiny přeložit přibližně do sousloví _typová variance_, ale setkáme se i s&nbsp;několika dalšími způsoby překladu. V&nbsp;této knize ovšem bude pravděpodobně nejlepší zůstat u původního označení, tedy u názvů _typová variance_ či jen zkráceně _variance_. Proč je však tento termín, resp.&nbsp;přesněji řečeno jeho význam, tak důležitý? Do značné míry totiž popisuje jednu důležitou vlastnost typového systému, která se týká hierarchie datových typů.\n\nOd hierarchie datových typů (a odvozeně i od třídní hierarchie, jak si ukážeme za chvíli) typicky vyžadujeme následující vlastnost: nějaký typ *T* je podtypem dalšího typu *U* za předpokladu, když ve všech místech programového kódu, v&nbsp;nichž je očekávána hodnota typu *U*, můžeme použít i hodnotu typu *T*. A dodejme, že v&nbsp;případě třídního objektově orientovaného programování (OOP) máme k&nbsp;dispozici podobnou vlastnost, která se většinou popisuje větou &bdquo;potomek vždy může nahradit předka&ldquo;, která ovšem vychází z&nbsp;dědičnosti. Nutno dodat, že dědičnost je vlastnost, která není na typové varianci přímo závislá.\n\nVariance resp.&nbsp;jedna konkrétní forma variance (viz další podkapitolu) pak určuje, jak a zda vůbec se toto pravidlo uplatní například u polí, resp.&nbsp;v&nbsp;případě Pythonu nejčastěji u seznamů (`List[T]` versus `List[U]`), slovníků, a jak později uvidíme, tak i u funkcí (typy parametrů a typ návratové hodnoty) atd.\n\n\n\n### Čtyři kategorie typových variancí\n\nCelkem existují čtyři kategorie typových variancí:\n\n1. Covariance (kovariance)\n1. Contravariance (kontravariance)\n1. Invariance\n1. Bivariance\n\nPoznámka: opět používám původní termíny, které se lépe vyhledávají. Invariance a bivariance se však nijak nepřekládá, jsou to přejatá slova používaná zcela běžně například v&nbsp;matematice.\n\n\n\n### Praktický příklad: ovoce a hrušky\n\nPodívejme se nyní na praktický příklad, jak se jednotlivé typy variance uplatní v&nbsp;některém typovém systému. Prozatím se bavíme o typových systémech obecně; typový systém programovacího jazyka Python bude zmíněn později. Budeme předpokládat, že máme nadefinovány dva datové typy nazvané `Ovoce` a `Hruška`, přičemž `Hruška` je podtypem datového typu `Ovoce` (což je pro nás zcela intuitivní). Na základě toho, jaký konkrétní typ variance daný typový systém používá,'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.8096651941371356, text='ěnitelné, což ovšem může být důsledky v&nbsp;době běhu programu (_runtime_).\n\n\n\n### Mají všechny typy variancí praktický význam?\n\nNa první pohled se to může možná zdát dosti podivné, ale všechny typy variance zmíněné v&nbsp;předchozím textu mají svůj význam a hlavně i praktické použití, i když se mohou zdát na první pohled &bdquo;nelogické&ldquo;. Ostatně některé příklady si ukážeme v&nbsp;navazujících podkapitolách. Situace je zajímavá zejména u funkcí, resp.&nbsp;u jejich parametrů a návratové hodnoty, protože právě zde se uplatňuje zdánlivě nelogická _kontravariance_ i když by se mohlo zdát, že jedinou ve všech oblastech &bdquo;správnou&ldquo; variancí je _kovariance_.\n\n\n\n### Malá odbočka: variance v&nbsp;klasickém objektově orientovaném jazyce\n\nS&nbsp;variancemi (přesněji řečeno těmi alespoň na první pohled &bdquo;logickými&ldquo;) se setkáme v&nbsp;klasických programovacích jazycích založených na myšlence objektově orientovaného programování. Příkladem může být C# či Java (v&nbsp;některých případech i TypeScript, který však umožňuje varianci změnit klíčovými slovy `in` a `out`). Programovací jazyk Java, na rozdíl od programovacího jazyka Go (který není čistě OOP jazykem), při volání funkcí a metod používají _kovarianci_, což ovšem může vést k&nbsp;běhovým (_runtime_) chybám. To si ostatně můžeme ukázat na velmi jednoduchých příkladech (subtyping je sice odlišný od hierarchie tříd, pro jednoduchost ovšem nyní budeme na chvíli tyto rozdíly ignorovat).\n\n\n\n#### Hierarchie tříd `Ovoce`, `Hruska` a `Jablko`\n\nV&nbsp;prvním příkladu naprogramovaném v&nbsp;Javě je použita snadno pochopitelná hierarchie tříd `Ovoce`, `Hruska` a `Jablko` (takže se vracíme k&nbsp;našemu příkladu s&nbsp;ovocem). Ve statické metodě `smichej` v&nbsp;košíku mícháme hrušky s&nbsp;jablky (sic!). Ovšem této metodě předáváme košík představovaný polem hodnot typu `Ovoce`, takže vše bude v&nbsp;pořádku &ndash; jak v&nbsp;čase překladu (_compile time_), tak i v&nbsp;čase běhu (_runtime_):\n\n```java\nclass Ovoce {\n}\n\nclass Hruska extends Ovoce {\n    public String toString() {\n        return "Hruska";\n    }\n}\n\nclass Jablko extends Ovoce {\n    public String toString() {\n        return "Jablko";\n    }\n}\n\npublic class Variance1 {\n    public static void smichej(Ovoce[] kosik) {\n        kosik[0] = new Hruska();\n        kosik[1] = new Jablko();\n    }\n\n    public static void main(String[] args) {\n        Ovoce[] kosik = new Ovoce[2];\n        smichej(kosik);\n\n        for (Ovoce ovoce:kosik) {\n            System.out.println(ovoce);\n        }\n    }\n}\n```\n\n\n\n#### Problémový rys kovariance\n\nAž dop'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.7955948611351027, text=' `tiskni`\n\nJen pro úplnost si ukažme, jak vlastně bude vypadat typová anotace funkce `tiskni`. Samotnou anotaci přečteme ze speciálního atributu `__annotations__`:\n\n@ mypy/variance-5.py\n\nPo spuštění tohoto demonstračního příkladu by se měla zobrazit tato anotace:\n\n```\n{\'kosik\': typing.Sequence[__main__.Ovoce], \'return\': None}\n```\n\n\n\n### Variance a typ funkce (`Callable`)\n\nVraťme se ještě k&nbsp;funkcím a jejich typu `Callable`. Připomeňme si, že jsme si ukazovali příklad s&nbsp;plně typově popsanou funkcí vyššího řádu nazvanou `printIsPositive`, která vypadala následovně:\n\n```python\ndef printIsPositive(x:float, condition:Callable[[float], bool]) -> None:\n    if condition(x):\n        print("Positive")\n    else:\n        print("Negative")\n```\n\nTato funkce tedy jako svůj druhý parametr akceptuje jinou funkci s&nbsp;parametrem typu `float`. Jak se ovšem bude příklad chovat ve chvíli, kdy předáme funkci s&nbsp;parametrem typu `int`? V&nbsp;běžném kódu je možné hodnoty typu `int` použít všude tam, kde je očekáván typ `float`, což ovšem nemusí platit v&nbsp;tomto zobecněném případě (viz příklad s&nbsp;ovocem &ndash; vztah mezi `Hruska` a `Ovoce` se netýká vztahu mezi `List[Hruska]` a `List[Ovoce]` &ndash; ty jsou obecně invariantní):\n\n@ mypy/callable-4.py\n\nSpustíme nástroj Mypy a zjistíme, jaké chyby jsme ve zdrojovém kódu &bdquo;nasekali&ldquo; tentokrát:\n\n```\ncallable-4.py:27: error: Argument 2 to "printIsPositive" has incompatible type "Callable[[int], bool]"; expected "Callable[[float], bool]"  [arg-type]\ncallable-4.py:28: error: Argument 2 to "printIsPositive" has incompatible type "Callable[[int], bool]"; expected "Callable[[float], bool]"  [arg-type]\nFound 2 errors in 1 file (checked 1 source file)\n```\n\nV&nbsp;tomto zdrojovém kódu totiž na scénu (opět) přichází problematika _variancí_, resp.&nbsp;její dva typy &ndash; kovariance a kontravariance.\n\n\n\n#### Argumenty jsou kontravariantní, zatímco návratová hodnota je kovariantní\n\nU datového typu &bdquo;funkce&ldquo; (tedy `Callable`) v&nbsp;programovacím jazyku Python platí tato důležitá poučka: argumenty/parametry jsou kontravariantní, kdežto návratová hodnota je kovariantní. Zajímavá je zejména kontravariance parametrů resp.&nbsp;při volání argumentů, takže si předchozí demonstrační příklad zjednodušme &ndash; nebudeme funkci vyššího řádu předávat dva argumenty, ale pouze jediný argumenty typu `Callable`:\n\n@ mypy/callable-5.py\n\nVýsledky typové kontroly provedené nástrojem Mypy budou velmi důležité:\n\n```\nmypy callable-5.py\n\ncallable-5.py:26: error: Argument 1 to "printIsPositive" has incompatible type "Callable[[int], bool]"; expected'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.7886989203336103, text=' `utrhni`, která získá jeden kus ovoce (tedy instanci nějaké třídy z&nbsp;naší hierarchie) a vrátí ho. A pro získání ovoce se volá nějaká funkce předaná v&nbsp;argumentu funkce `utrhni`. Může se jednat o konstruktor třídy `Hruska` či `Jablko`, protože konstruktory se v&nbsp;tomto ohledu chovají podobně jako běžné funkce:\n\n@ mypy/variance-6.py\n\nTypové kontroly v&nbsp;tomto případě nenaleznou žádný problém:\n\n```\n$ mypy variance-6.py \n\nSuccess: no issues found in 1 source file\n```\n\n'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.7881010796465837, text=', že dědičnost je vlastnost, která není na typové varianci přímo závislá.\n\nVariance resp.&nbsp;jedna konkrétní forma variance (viz další podkapitolu) pak určuje, jak a zda vůbec se toto pravidlo uplatní například u polí, resp.&nbsp;v&nbsp;případě Pythonu nejčastěji u seznamů (`List[T]` versus `List[U]`), slovníků, a jak později uvidíme, tak i u funkcí (typy parametrů a typ návratové hodnoty) atd.\n\n\n\n### Čtyři kategorie typových variancí\n\nCelkem existují čtyři kategorie typových variancí:\n\n1. Covariance (kovariance)\n1. Contravariance (kontravariance)\n1. Invariance\n1. Bivariance\n\nPoznámka: opět používám původní termíny, které se lépe vyhledávají. Invariance a bivariance se však nijak nepřekládá, jsou to přejatá slova používaná zcela běžně například v&nbsp;matematice.\n\n\n\n### Praktický příklad: ovoce a hrušky\n\nPodívejme se nyní na praktický příklad, jak se jednotlivé typy variance uplatní v&nbsp;některém typovém systému. Prozatím se bavíme o typových systémech obecně; typový systém programovacího jazyka Python bude zmíněn později. Budeme předpokládat, že máme nadefinovány dva datové typy nazvané `Ovoce` a `Hruška`, přičemž `Hruška` je podtypem datového typu `Ovoce` (což je pro nás zcela intuitivní). Na základě toho, jaký konkrétní typ variance daný typový systém používá, mohou nastat čtyři varianty uplatněné na typy &bdquo;seznam ovoce&ldquo; a &bdquo;seznam hrušek&ldquo; (popř.&nbsp;si namísto &bdquo;seznam&ldquo; můžete doplnit &bdquo;pole&ldquo; nebo libovolnou jinou datovou kolekci, například množinu nebo i zásobník či frontu):\n\n1. _Covariance_: v&nbsp;tomto případě je `List[Hruška]` podtypem typu `List[Ovoce]` což v&nbsp;praxi znamená, že libovolná funkce akceptující argument typu `List[Ovoce]` bude akceptovat i argument typu `List[Hruška]`.\n\n1. _Contravariance_: v&nbsp;takto koncipovaném typovém systému bude `List[Ovoce]` podtypem typu `List[Hruška]` (což je jen zdánlivě nelogické), což znamená, že libovolná funkce akceptující argument `List[Hruška]` bude akceptovat i argument typu `List[Ovoce]`.\n\n1. _Invariance_: datový typ `List[Ovoce]` nemá z&nbsp;hlediska datového systému žádný vztah k `List[Hruška]` a při volání funkcí je tedy nelze zaměňovat. Tato varianta je sice typově bezpečná, ale může být v&nbsp;praxi poměrně rigidní.\n\n1. _Bivariance_: datový typ `List[Hruška]` je v&nbsp;tomto případě podtypem typu `List[Ovoce]` a současně `List[Ovoce]` je podtypem typu `List[Hruška]`. Tyto typy jsou tedy při volání zam'), OutputOpenAIResponseOutputMessageFileSearchToolCallResult(attributes={}, file_id='', filename='', score=1.7780943127150388, text=']` ale typu `List[Hruska]`, přičemž ve funkci `smichej` opět mícháme jablka s&nbsp;hruškami, ovšem nyní je přidáváme do seznamu, který akceptuje pouze hrušky. Jedná se tedy o obdobu druhého příkladu naprogramovaného v&nbsp;Javě, nyní ovšem zapsaného v&nbsp;jazyku s&nbsp;odlišným typovým systémem:\n\n@ mypy/variance-2.py\n\nTentokrát ovšem nástroj Mypy ve zdrojovém kódu nalezne chyby a dokonce navrhuje způsob jejich opravy. Tuto opravu ale, alespoň prozatím, nemůžeme použít:\n\n```\nmypy --strict variance-2.py \n\nvariance-2.py:31: error: Argument 1 to "smichej" has incompatible type "List[Hruska]"; expected "List[Ovoce]"  [arg-type]\nvariance-2.py:31: note: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance\nvariance-2.py:31: note: Consider using "Sequence" instead, which is covariant\nFound 1 error in 1 file (checked 1 source file)\n```\n\nNástroj Mypy (a především typový systém Pythonu) se tedy v&nbsp;tomto ohledu dosti podstatným způsobem odlišuje od typového systému Javy! Navíc nám tyto změny (resp.&nbsp;vylepšení) typového systému umožňují statickou typovou kontrolu, což v&nbsp;Javě nebylo plně možné.\n\n\n\n#### Úprava příkladu: tisk obsahu košíku s&nbsp;ovocem\n\nV&nbsp;navazujícím kroku demonstrační příklad z&nbsp;předchozího odstavce do určité míry zjednodušíme. Zjednodušení přitom provedeme takovým způsobem, že si nadefinujeme funkci nazvanou `tiskni`, která očekává jako svůj jediný argument hodnotu typu `List[Ovoce]` (tedy seznam s&nbsp;libovolnými kousky ovoce &ndash; hrušky i jablky). A otestujeme si, jestli je možné této funkci předat seznam s&nbsp;hruškami, tedy argument typu `List[Hruska]`.\n\nPři statické kontrole datových typů by se v&nbsp;tomto případě měl objevit stejný problém, jako u předchozího zdrojového kódu a to z&nbsp;toho důvodu, že se kontrolují pouze datové typy a nástroj Mypy netuší, jaké operace se budou interně se seznamem provádět:\n\n@ mypy/variance-3.py\n\nPodle našich očekávání nástroj Mypy skutečně nalezne podobnou chybu, jako tomu bylo v&nbsp;předchozím zdrojovém kódu:\n\n```\nmypy variance-3.py \n\nvariance-3.py:31: error: Argument 1 to "tiskni" has incompatible type "List[Hruska]"; expected "List[Ovoce]"  [arg-type]\nvariance-3.py:31: note: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance\nvariance-3.py:31: note: Consider using "Sequence" instead, which is covariant\nFound 1 error in 1 file (checked 1 source file)\n```\n\n\n\n#### Využití datového typu `Sequence` namísto invariantního typu `List`\n\nNástroj Mypy nám v&nbsp;tomto případě velmi správně')]

--- Output Item 2 ---
Output type: message
Response content: The class `Ovoce` along with its subclasses `Hruska` (Pear) and `Jablko` (Apple) are defined in a programming example to illustrate the concept of variance in object-oriented programming. Below is the definition of these classes in Java:

```java
class Ovoce {
}

class Hruska extends Ovoce {
    public String toString() {
        return "Hruska";
    }
}

class Jablko extends Ovoce {
    public String toString() {
        return "Jablko";
    }
}
```

This hierarchy involves a base class `Ovoce`, with two derived classes `Hruska` and `Jablko`. The `toString()` method in both subclasses provides a simple way to return the string representation of each fruit. This basic class structure is used to demonstrate type variance and how objects of these types interact within an array specified as type `Ovoce`, addressing concepts such as compile-time and runtime type safety in Java.

